{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>geoarrow.rust.core</code>","text":"<p>Python bindings to <code>geoarrow-rs</code></p>"},{"location":"#overview","title":"Overview","text":"<p>This library contains Python bindings to the GeoArrow Rust implementation.</p> <ul> <li>Fast: Connects to algorithms implemented in GeoRust, which compile to native code.</li> <li>Parallel: Multi-threading is enabled out-of-the-box for all operations on chunked data structures.</li> <li>Self-contained: Zero Python dependencies.</li> <li>Easy to install: Distributed as static binary wheels with zero C dependencies.</li> <li>Strong, static typing: geometry arrays have a known type</li> <li>Interoperable ecosystem: Data is shared at zero cost with other Python libraries in the burgeoning GeoArrow ecosystem, such as geoarrow-c or lightning-fast map rendering.</li> </ul> <p>More specifically, it contains:</p> <ul> <li>Classes to represent GeoArrow arrays: <code>PointArray</code>, <code>LineStringArray</code>, etc.</li> <li>Classes to represent chunked GeoArrow arrays: <code>ChunkedPointArray</code>, <code>ChunkedLineStringArray</code>, etc.</li> <li>A spatial table representation, <code>GeoTable</code>, where one column is a geospatial type, to enable future support for geospatial joins.</li> <li>Rust-based algorithms for computations on GeoArrow memory.</li> <li>Rust-based parsers for various geospatial file formats.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation at geoarrow.github.io/geoarrow-rs/python.</p>"},{"location":"#future-work","title":"Future work:","text":"<ul> <li> 3D coordinates. Only 2D geometries are supported at this time.</li> <li> More algorithms, including spatial indexes and spatial joins.</li> <li> CRS management. This currently loses the CRS information in the GeoArrow metadata.</li> </ul>"},{"location":"#background-reading","title":"Background reading","text":"<p>Refer to the GeoArrow Python module proposal for more background information.</p>"},{"location":"api/core/functions/","title":"Top-level functions","text":""},{"location":"api/core/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/functions/#geoarrow.rust.core.area","title":"area  <code>builtin</code>","text":"<pre><code>area(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.signed_area","title":"signed_area  <code>builtin</code>","text":"<pre><code>signed_area(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.center","title":"center  <code>builtin</code>","text":"<pre><code>center(input: ArrowArrayExportable) -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.centroid","title":"centroid  <code>builtin</code>","text":"<pre><code>centroid(input: ArrowArrayExportable) -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.chaikin_smoothing","title":"chaikin_smoothing  <code>builtin</code>","text":"<pre><code>chaikin_smoothing(input: ArrowArrayExportable, n_iterations: int) -&gt; LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>builtin</code>","text":"<pre><code>chamberlain_duquette_unsigned_area(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>builtin</code>","text":"<pre><code>chamberlain_duquette_signed_area(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.convex_hull","title":"convex_hull  <code>builtin</code>","text":"<pre><code>convex_hull(input: ArrowArrayExportable) -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.densify","title":"densify  <code>builtin</code>","text":"<pre><code>densify(input: ArrowArrayExportable, max_distance: float) -&gt; LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.envelope","title":"envelope  <code>builtin</code>","text":"<pre><code>envelope(input: ArrowArrayExportable) -&gt; RectArray\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RectArray</code>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.is_empty","title":"is_empty  <code>builtin</code>","text":"<pre><code>is_empty(input: ArrowArrayExportable) -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_signed","title":"geodesic_area_signed  <code>builtin</code>","text":"<pre><code>geodesic_area_signed(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>builtin</code>","text":"<pre><code>geodesic_area_unsigned(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_perimeter","title":"geodesic_perimeter  <code>builtin</code>","text":"<pre><code>geodesic_perimeter(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.simplify","title":"simplify  <code>builtin</code>","text":"<pre><code>simplify(input: ArrowArrayExportable, epsilon: float) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.simplify_vw","title":"simplify_vw  <code>builtin</code>","text":"<pre><code>simplify_vw(input: ArrowArrayExportable, epsilon: float) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/io/","title":"I/O","text":""},{"location":"api/core/io/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/io/#geoarrow.rust.core.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.to_wkb","title":"to_wkb  <code>builtin</code>","text":"<pre><code>to_wkb(input: ArrowArrayExportable) -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_csv","title":"read_csv  <code>builtin</code>","text":"<pre><code>read_csv(path: str, geometry_column_name: str) -&gt; GeoTable\n</code></pre> <p>Read a CSV file from a path on disk into a GeoTable.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the path to the file</p> </li> <li> <code>geometry_column_name</code>             (<code>str</code>)         \u2013          <p>the name of the geometry column within the CSV.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from CSV file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_flatgeobuf","title":"read_flatgeobuf  <code>builtin</code>","text":"<pre><code>read_flatgeobuf(path: str, batch_size: Optional[int] = None) -&gt; GeoTable\n</code></pre> <p>Read a FlatGeobuf file from a path on disk into a GeoTable.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the path to the file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_geojson","title":"read_geojson  <code>builtin</code>","text":"<pre><code>read_geojson(path: str, batch_size: Optional[int] = None) -&gt; GeoTable\n</code></pre> <p>Read a GeoJSON file from a path on disk into a GeoTable.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the path to the file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from GeoJSON file.</p> </li> </ul>"},{"location":"api/core/table/","title":"GeoTable","text":""},{"location":"api/core/table/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/table/#geoarrow.rust.core.GeoTable","title":"GeoTable","text":"<p>A spatially-enabled table.</p> <p>This is a table, or <code>DataFrame</code>, consisting of named columns with the same length. One of these columns contains a chunked geometry array.</p> <p>This is similar to a GeoPandas <code>GeoDataFrame</code>.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.geometry","title":"geometry","text":"<pre><code>geometry: ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray | ChunkedMixedGeometryArray | ChunkedGeometryCollectionArray = &lt;attribute 'geometry' of 'geoarrow.rust.core.rust.GeoTable' objects&gt;\n</code></pre> <p>Access the geometry column of this table</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray | ChunkedMixedGeometryArray | ChunkedGeometryCollectionArray</code>         \u2013          <p>A chunked geometry array</p> </li> </ul>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.num_columns","title":"num_columns","text":"<pre><code>num_columns: int = &lt;attribute 'num_columns' of 'geoarrow.rust.core.rust.GeoTable' objects&gt;\n</code></pre> <p>Number of columns in this table.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.table()</code> to convert this array into a pyarrow table, without copying memory.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowStreamExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types","title":"geoarrow.rust.core.types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types.ArrowArrayExportable","title":"ArrowArrayExportable","text":"<p>             Bases: <code>Protocol</code></p> <p>An Arrow or GeoArrow array from an Arrow producer (e.g. geoarrow.c or pyarrow).</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.ArrowStreamExportable","title":"ArrowStreamExportable","text":"<p>             Bases: <code>Protocol</code></p> <p>An Arrow or GeoArrow ChunkedArray or Table from an Arrow producer (e.g. geoarrow.c or pyarrow).</p>"},{"location":"api/core/geometry/array/","title":"Geometry Arrays","text":"<p>The classes on this page represent arrays of geospatial geometries.</p> <ul> <li><code>PointArray</code></li> <li><code>LineStringArray</code></li> <li><code>PolygonArray</code></li> <li><code>MultiPointArray</code></li> <li><code>MultiLineStringArray</code></li> <li><code>MultiPolygonArray</code></li> <li><code>MixedGeometryArray</code></li> <li><code>GeometryCollectionArray</code></li> <li><code>WKBArray</code></li> <li><code>RectArray</code></li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray","title":"PointArray","text":"<p>An immutable array of Point geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; Float64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; Float64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray","title":"LineStringArray","text":"<p>An immutable array of LineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; Float64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; Float64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray","title":"PolygonArray","text":"<p>An immutable array of Polygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray","title":"MultiPointArray","text":"<p>An immutable array of MultiPoint geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; Float64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; Float64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray","title":"MultiLineStringArray","text":"<p>An immutable array of MultiLineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; Float64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; Float64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray","title":"MultiPolygonArray","text":"<p>An immutable array of MultiPolygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray","title":"MixedGeometryArray","text":"<p>An immutable array of Geometry geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray","title":"GeometryCollectionArray","text":"<p>An immutable array of GeometryCollection geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray","title":"WKBArray","text":"<p>An immutable array of WKB-encoded geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(ob)\n</code></pre> <p>Construct this object from existing Arrow data</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray","title":"RectArray","text":"<p>An immutable array of Rect geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None)\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.to_polygon_array","title":"to_polygon_array  <code>method descriptor</code>","text":"<pre><code>to_polygon_array() -&gt; PolygonArray\n</code></pre> <p>Convert this array to a PolygonArray</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with polygon geometries</p> </li> </ul>"},{"location":"api/core/geometry/chunked/","title":"Chunked Geometry Arrays","text":"<p>Chunked arrays of geospatial geometries, each of the same type.</p> <ul> <li><code>ChunkedPointArray</code></li> <li><code>ChunkedLineStringArray</code></li> <li><code>ChunkedPolygonArray</code></li> <li><code>ChunkedMultiPointArray</code></li> <li><code>ChunkedMultiLineStringArray</code></li> <li><code>ChunkedMultiPolygonArray</code></li> <li><code>ChunkedMixedGeometryArray</code></li> <li><code>ChunkedGeometryCollectionArray</code></li> <li><code>ChunkedWKBArray</code></li> <li><code>ChunkedRectArray</code></li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray","title":"ChunkedPointArray","text":"<p>An immutable chunked array of Point geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[PointArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; PointArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; ChunkedFloat64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray","title":"ChunkedLineStringArray","text":"<p>An immutable chunked array of LineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[LineStringArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; LineStringArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; ChunkedFloat64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray","title":"ChunkedPolygonArray","text":"<p>An immutable chunked array of Polygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[PolygonArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; PolygonArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray","title":"ChunkedMultiPointArray","text":"<p>An immutable chunked array of MultiPoint geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiPointArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiPointArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; ChunkedFloat64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray","title":"ChunkedMultiLineStringArray","text":"<p>An immutable chunked array of MultiLineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiLineStringArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiLineStringArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length() -&gt; ChunkedFloat64Array\n</code></pre> <p>(Euclidean) Calculation of the length of a Line</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray","title":"ChunkedMultiPolygonArray","text":"<p>An immutable chunked array of MultiPolygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiPolygonArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiPolygonArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float) -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon: float) -&gt; Self\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray","title":"ChunkedMixedGeometryArray","text":"<p>An immutable chunked array of Geometry geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MixedGeometryArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MixedGeometryArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray","title":"ChunkedGeometryCollectionArray","text":"<p>An immutable chunked array of GeometryCollection geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry array</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[GeometryCollectionArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; GeometryCollectionArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry array</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray","title":"ChunkedWKBArray","text":"<p>An immutable chunked array of WKB-encoded geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[WKBArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(ob: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray","title":"ChunkedRectArray","text":"<p>An immutable chunked array of Rect geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[RectArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/primitive/array/","title":"Primitive Arrays","text":"<p>Arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>BooleanArray</code></li> </ul> <ul> <li><code>Float64Array</code></li> </ul>"},{"location":"api/core/primitive/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray","title":"BooleanArray","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array","title":"Float64Array","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.float64]\n</code></pre> <p>Copy this array to a <code>numpy</code> NDArray</p>"},{"location":"api/core/primitive/chunked/","title":"Chunked Primitive Arrays","text":"<p>Chunked arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>ChunkedBooleanArray</code></li> </ul> <ul> <li><code>ChunkedFloat64Array</code></li> </ul>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray","title":"ChunkedBooleanArray","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[BooleanArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array","title":"ChunkedFloat64Array","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[Float64Array]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"ecosystem/geopandas/","title":"GeoPandas","text":"<p>Note that this loses the CRS information on the GeoDataFrame, but geoarrow-rust is not yet able to persist the CRS information. <pre><code>from geoarrow.rust.core import GeoTable\nfrom pyarrow import Table\n\ngdf = GeoDataFrame()\ntable = Table.from_pandas(gdf.to_wkb(flavor=\"iso\"))\ntable = GeoTable.from_arrow(table)\n</code></pre></p> <p>And back:</p> <p>We need a to_wkb() on the table <pre><code>pyarrow_table = pa.table(geo_table)\n</code></pre></p>"},{"location":"ecosystem/lonboard/","title":"Lonboard","text":"<p>TODO: seems a bit slow to create the PathLayer from arrow?</p> <pre><code>from lonboard import PathLayer\nimport pyarrow as pa\nfrom geoarrow.rust.core import GeoTable\nfrom pyogrio.raw import read_arrow\n\npath = \"/Users/kyle/github/geoarrow/geoarrow-rs/python/core/ne_10m_roads_north_america/ne_10m_roads_north_america.shp\"\nmeta, table = read_arrow(path)\n\ngeo_table = GeoTable.from_arrow(table)\ngeo_table.geometry\n\n%time layer = PathLayer(table=pa.table(geo_table))\n</code></pre>"},{"location":"ecosystem/pyogrio/","title":"Pyogrio/GDAL","text":"<p>Pyogrio has a <code>read_arrow</code> method that uses OGR to read in any supported vector file as an Arrow Table. We can pass that table to the <code>from_arrow</code> method on <code>GeoTable</code>.</p> <pre><code>from geoarrow.rust.core import GeoTable\nfrom pyogrio.raw import read_arrow\n\npath = \"path/to/file.shp\"\nmeta, table = read_arrow(path)\n\ntable = GeoTable.from_arrow(table)\ntable.geometry\n# &lt;geoarrow.rust.core.rust.ChunkedMultiLineStringArray at 0x13fb61e70&gt;\n</code></pre>"},{"location":"ecosystem/shapely/","title":"Shapely","text":"<p>Suggest WKB for shapely interop.</p> <p>In the future, it will be easier to go directly to/from shapely</p>"}]}