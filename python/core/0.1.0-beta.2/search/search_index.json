{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>GeoArrow</p>"},{"location":"api/","title":"geoarrow.rust.core","text":"<p>At this point, all exports are provided at the top level.</p>"},{"location":"api/functions/","title":"Top-level functions","text":""},{"location":"api/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/functions/#geoarrow.rust.core.area","title":"area  <code>builtin</code>","text":"<pre><code>area(ob) -&gt; Float64Array\n</code></pre>"},{"location":"api/functions/#geoarrow.rust.core.signed_area","title":"signed_area  <code>builtin</code>","text":"<pre><code>signed_area(ob) -&gt; Float64Array\n</code></pre>"},{"location":"api/functions/#geoarrow.rust.core.center","title":"center  <code>builtin</code>","text":"<pre><code>center(ob) -&gt; PointArray\n</code></pre>"},{"location":"api/functions/#geoarrow.rust.core.centroid","title":"centroid  <code>builtin</code>","text":"<pre><code>centroid(ob) -&gt; PointArray\n</code></pre>"},{"location":"api/functions/#geoarrow.rust.core.convex_hull","title":"convex_hull  <code>builtin</code>","text":"<pre><code>convex_hull(ob) -&gt; PolygonArray\n</code></pre>"},{"location":"api/io/","title":"I/O","text":""},{"location":"api/io/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/io/#geoarrow.rust.core.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(ob) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Convert an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p>"},{"location":"api/io/#geoarrow.rust.core.to_wkb","title":"to_wkb  <code>builtin</code>","text":"<pre><code>to_wkb(ob) -&gt; WKBArray\n</code></pre> <p>Convert a GeoArrow-native geometry array to a WKBArray.</p>"},{"location":"api/geometry/array/","title":"Geometry Arrays","text":"<p>The classes on this page represent arrays of geospatial geometries.</p> <ul> <li><code>PointArray</code></li> <li><code>LineStringArray</code></li> <li><code>PolygonArray</code></li> <li><code>MultiPointArray</code></li> <li><code>MultiLineStringArray</code></li> <li><code>MultiPolygonArray</code></li> <li><code>MixedGeometryArray</code></li> <li><code>GeometryCollectionArray</code></li> <li><code>RectArray</code></li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray","title":"PointArray","text":""},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.euclidean_length","title":"euclidean_length  <code>method descriptor</code>","text":"<pre><code>euclidean_length()\n</code></pre> <p>Calculation of the length of a Line</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PointArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray","title":"LineStringArray","text":"<p>An immutable array of LineString geometries in WebAssembly memory using GeoArrow's in-memory representation.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.euclidean_length","title":"euclidean_length  <code>method descriptor</code>","text":"<pre><code>euclidean_length()\n</code></pre> <p>Calculation of the length of a Line</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.LineStringArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray","title":"PolygonArray","text":"<p>An immutable array of Polygon geometries in WebAssembly memory using GeoArrow's in-memory representation.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.PolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray","title":"MultiPointArray","text":"<p>An immutable array of MultiPoint geometries in WebAssembly memory using GeoArrow's in-memory representation.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.euclidean_length","title":"euclidean_length  <code>method descriptor</code>","text":"<pre><code>euclidean_length()\n</code></pre> <p>Calculation of the length of a Line</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPointArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray","title":"MultiLineStringArray","text":"<p>An immutable array of MultiLineString geometries in WebAssembly memory using GeoArrow's in-memory representation.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.euclidean_length","title":"euclidean_length  <code>method descriptor</code>","text":"<pre><code>euclidean_length()\n</code></pre> <p>Calculation of the length of a Line</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_length","title":"geodesic_length  <code>method descriptor</code>","text":"<pre><code>geodesic_length()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.haversine_length","title":"haversine_length  <code>method descriptor</code>","text":"<pre><code>haversine_length()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiLineStringArray.vincenty_length","title":"vincenty_length  <code>method descriptor</code>","text":"<pre><code>vincenty_length()\n</code></pre> <p>Determine the length of a geometry using Vincenty\u2019s formulae.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray","title":"MultiPolygonArray","text":"<p>An immutable array of MultiPolygon geometries in WebAssembly memory using GeoArrow's in-memory representation.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.bounding_rect","title":"bounding_rect  <code>method descriptor</code>","text":"<pre><code>bounding_rect() -&gt; RectArray\n</code></pre> <p>Return the bounding rectangle of a geometry</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chamberlain_duquette_signed_area","title":"chamberlain_duquette_signed_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_signed_area() -&gt; Float64Array\n</code></pre> <p>Calculate the signed approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chamberlain_duquette_unsigned_area","title":"chamberlain_duquette_unsigned_area  <code>method descriptor</code>","text":"<pre><code>chamberlain_duquette_unsigned_area() -&gt; Float64Array\n</code></pre> <p>Calculate the unsigned approximate geodesic area of a <code>Geometry</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed","title":"geodesic_area_signed  <code>method descriptor</code>","text":"<pre><code>geodesic_area_signed() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Feature standard.    Alternative windings may result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect to be dealing    with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_signed--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things: 1. The winding of the polygon is in the clockwise direction (reverse winding). If this is the case, and you know the polygon is smaller than half the area of earth, you can take the absolute value of the reported area to get the correct area. 2. The polygon is larger than half the planet. In this case, the returned area of the polygon is not correct. If you expect to be dealing with very large polygons, please use the <code>unsigned</code> methods.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned","title":"geodesic_area_unsigned  <code>method descriptor</code>","text":"<pre><code>geodesic_area_unsigned() -&gt; Float64Array\n</code></pre> <p>Determine the area of a geometry on an ellipsoidal model of the earth. Supports very large geometries that cover a significant portion of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction    for the exterior ring and a clockwise direction for interior rings.    This is the standard winding for geometries that follow the Simple Features standard.    Using alternative windings will result in incorrect results.</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_area_unsigned--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Some geometries, like a <code>MultiPoint</code>, can have zero coordinates - we call these <code>empty</code>.</p> <p>Types like <code>Point</code>, which have at least one coordinate by construction, can never be considered empty.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon)\n</code></pre> <p>Simplifies a geometry.</p> <p>The Ramer\u2013Douglas\u2013Peucker algorithm simplifies a linestring. Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.simplify_vw","title":"simplify_vw  <code>method descriptor</code>","text":"<pre><code>simplify_vw(epsilon)\n</code></pre> <p>Returns the simplified representation of a geometry, using the Visvalingam-Whyatt algorithm</p> <p>See here for a graphical explanation</p> <p>Polygons are simplified by running the algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p> <p>An epsilon less than or equal to zero will return an unaltered version of the geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MultiPolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray","title":"MixedGeometryArray","text":""},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.MixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray","title":"GeometryCollectionArray","text":""},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; Float64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p>"},{"location":"api/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/","title":"Chunked Geometry Arrays","text":"<p>Chunked arrays of geospatial geometries, each of the same type.</p> <ul> <li><code>ChunkedPointArray</code></li> <li><code>ChunkedLineStringArray</code></li> <li><code>ChunkedPolygonArray</code></li> <li><code>ChunkedMultiPointArray</code></li> <li><code>ChunkedMultiLineStringArray</code></li> <li><code>ChunkedMultiPolygonArray</code></li> <li><code>ChunkedMixedGeometryArray</code></li> <li><code>ChunkedGeometryCollectionArray</code></li> <li><code>ChunkedRectArray</code></li> </ul>"},{"location":"api/geometry/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray","title":"ChunkedPointArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray","title":"ChunkedLineStringArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray","title":"ChunkedPolygonArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray","title":"ChunkedMultiPointArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray","title":"ChunkedMultiLineStringArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray","title":"ChunkedMultiPolygonArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray","title":"ChunkedMixedGeometryArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray","title":"ChunkedGeometryCollectionArray","text":""},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area() -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned planar area of a geometry.</p>"},{"location":"api/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area()\n</code></pre> <p>Signed planar area of a geometry.</p>"},{"location":"api/primitive/array/","title":"Primitive Arrays","text":"<p>Arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>BooleanArray</code></li> <li><code>Float16Array</code></li> <li><code>Float32Array</code></li> <li><code>Float64Array</code></li> <li><code>UInt8Array</code></li> <li><code>UInt16Array</code></li> <li><code>UInt32Array</code></li> <li><code>UInt64Array</code></li> <li><code>Int8Array</code></li> <li><code>Int16Array</code></li> <li><code>Int32Array</code></li> <li><code>Int64Array</code></li> <li><code>StringArray</code></li> <li><code>LargeStringArray</code></li> </ul>"},{"location":"api/primitive/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.BooleanArray","title":"BooleanArray","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.BooleanArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Float16Array","title":"Float16Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Float16Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Float32Array","title":"Float32Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Float32Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Float32Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.float32]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Float64Array","title":"Float64Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Float64Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Float64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.float64]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt8Array","title":"UInt8Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.UInt8Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt8Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.uint8]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt16Array","title":"UInt16Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.UInt16Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt16Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.uint16]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt32Array","title":"UInt32Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.UInt32Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt32Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.uint32]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt64Array","title":"UInt64Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.UInt64Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.UInt64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.uint64]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int8Array","title":"Int8Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Int8Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int8Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.int8]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int16Array","title":"Int16Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Int16Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int16Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.int16]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int32Array","title":"Int32Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Int32Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int32Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.int32]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int64Array","title":"Int64Array","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.Int64Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.Int64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.int64]\n</code></pre> <p>Convert to a <code>numpy</code> NDArray</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.StringArray","title":"StringArray","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.StringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/array/#geoarrow.rust.core.LargeStringArray","title":"LargeStringArray","text":""},{"location":"api/primitive/array/#geoarrow.rust.core.LargeStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(_requested_schema=None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface</p>"},{"location":"api/primitive/chunked/","title":"Chunked Primitive Arrays","text":"<p>Chunked arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>ChunkedBooleanArray</code></li> <li><code>ChunkedFloat16Array</code></li> <li><code>ChunkedFloat32Array</code></li> <li><code>ChunkedFloat64Array</code></li> <li><code>ChunkedUInt8Array</code></li> <li><code>ChunkedUInt16Array</code></li> <li><code>ChunkedUInt32Array</code></li> <li><code>ChunkedUInt64Array</code></li> <li><code>ChunkedInt8Array</code></li> <li><code>ChunkedInt16Array</code></li> <li><code>ChunkedInt32Array</code></li> <li><code>ChunkedInt64Array</code></li> <li><code>ChunkedStringArray</code></li> <li><code>ChunkedLargeStringArray</code></li> </ul>"},{"location":"api/primitive/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray","title":"ChunkedBooleanArray","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedFloat16Array","title":"ChunkedFloat16Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedFloat32Array","title":"ChunkedFloat32Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array","title":"ChunkedFloat64Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedUInt8Array","title":"ChunkedUInt8Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedUInt16Array","title":"ChunkedUInt16Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedUInt32Array","title":"ChunkedUInt32Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedUInt64Array","title":"ChunkedUInt64Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedInt8Array","title":"ChunkedInt8Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedInt16Array","title":"ChunkedInt16Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedInt32Array","title":"ChunkedInt32Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedInt64Array","title":"ChunkedInt64Array","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedStringArray","title":"ChunkedStringArray","text":""},{"location":"api/primitive/chunked/#geoarrow.rust.core.ChunkedLargeStringArray","title":"ChunkedLargeStringArray","text":""}]}